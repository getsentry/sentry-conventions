import * as fs from 'node:fs';
import * as path from 'node:path';

interface AttributeJson {
  key: string;
  brief: string;
  has_dynamic_suffix?: boolean;
  type: 'string' | 'boolean' | 'integer' | 'double' | 'string[]' | 'boolean[]' | 'integer[]' | 'double[]';
  pii: {
    key: 'true' | 'maybe' | 'false';
    reason?: string;
  };
  is_in_otel: boolean;
  example?: string | boolean | number | string[] | boolean[] | number[];
  deprecation?: {
    replacement: string;
    reason?: string;
  };
  alias?: string[];
  sdks?: string[];
}

// Function to read and parse a JSON file
function readJsonFile(filePath: string): AttributeJson {
  const fileContent = fs.readFileSync(filePath, 'utf8');
  return JSON.parse(fileContent) as AttributeJson;
}

// Function to generate a markdown table for a single attribute
function generateAttributeTable(attribute: AttributeJson): string {
  let table = `## ${attribute.key}\n\n`;
  table += `${attribute.brief}\n\n`;
  table += '| Property | Value |\n';
  table += '| --- | --- |\n';
  table += `| Type | \`${attribute.type}\` |\n`;

  const piiValue = attribute.pii.key + (attribute.pii.reason ? ` (${attribute.pii.reason})` : '');
  table += `| Has PII | ${piiValue} |\n`;

  table += `| Exists in OpenTelemetry | ${attribute.is_in_otel ? 'Yes' : 'No'} |\n`;

  if (attribute.has_dynamic_suffix) {
    table += '| Has dynamic suffix | Yes |\n';
  }

  if (attribute.example !== undefined) {
    const exampleValue =
      typeof attribute.example === 'object' ? JSON.stringify(attribute.example) : String(attribute.example);
    table += `| Example | \`${exampleValue}\` |\n`;
  }

  if (attribute.deprecation) {
    table += `| Deprecated | Yes, use \`${attribute.deprecation.replacement}\` instead |\n`;
    if (attribute.deprecation.reason) {
      table += `| Deprecation Reason | ${attribute.deprecation.reason} |\n`;
    }
  }

  if (attribute.alias && attribute.alias.length > 0) {
    table += `| Aliases | ${attribute.alias.map((a) => `\`${a}\``).join(', ')} |\n`;
  }

  table += '\n';

  table = table.replaceAll('<key>', '\\<key\\>');

  return table;
}

// Main function to generate all markdown docs
async function generateAttributeDocs() {
  const baseDir = 'model/attributes';
  const outputDir = 'generated/attributes';
  const categories: Record<string, AttributeJson[]> = {};

  // Ensure output directory exists
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  // Process top-level files (they go into a "general" category)
  const topLevelFiles = fs
    .readdirSync(baseDir)
    .filter((file) => file.endsWith('.json'))
    .map((file) => path.join(baseDir, file));

  if (topLevelFiles.length > 0) {
    categories.general = topLevelFiles.map((file) => readJsonFile(file));
  }

  // Process subdirectories
  const subdirs = fs
    .readdirSync(baseDir, { withFileTypes: true })
    .filter((dirent) => dirent.isDirectory())
    .map((dirent) => dirent.name);

  for (const subdir of subdirs) {
    const categoryDir = path.join(baseDir, subdir);
    const files = fs
      .readdirSync(categoryDir)
      .filter((file) => file.endsWith('.json'))
      .map((file) => path.join(categoryDir, file));

    if (files.length > 0) {
      categories[subdir] = files.map((file) => readJsonFile(file));
    }
  }

  // Generate markdown files for each category
  for (const [category, attributes] of Object.entries(categories)) {
    // Add autogenerated warning
    let markdown = '<!-- THIS FILE IS AUTO-GENERATED. DO NOT EDIT DIRECTLY. -->\n\n';
    markdown += `# ${category.charAt(0).toUpperCase() + category.slice(1)} Attributes\n\n`;

    // Sort attributes alphabetically by key
    attributes.sort((a, b) => a.key.localeCompare(b.key));

    // Generate tables for each attribute
    for (const attribute of attributes) {
      markdown += generateAttributeTable(attribute);
    }

    // Write the markdown file
    const outputFile = path.join(outputDir, `${category}.md`);
    fs.writeFileSync(outputFile, markdown);
    console.log(`Generated documentation for ${category} attributes: ${outputFile}`);
  }

  // Create index.md file that links to all categories
  let indexContent = '<!-- THIS FILE IS AUTO-GENERATED. DO NOT EDIT DIRECTLY. -->\n\n';
  indexContent += '# Attribute Documentation\n\n';
  indexContent += 'This directory contains documentation for all available attributes.\n\n';
  indexContent += '## Available Categories\n\n';

  // Generate links to each category
  for (const category of Object.keys(categories).sort()) {
    indexContent += `- [\`${category}\` Attributes](./${category}.md)\n`;
  }

  // Write the index.md file
  const indexFile = path.join(outputDir, 'index.md');
  fs.writeFileSync(indexFile, indexContent);
  console.log(`Generated index file: ${indexFile}`);

  console.log('Documentation generation complete!');
}

// Run the script
generateAttributeDocs().catch(console.error);
